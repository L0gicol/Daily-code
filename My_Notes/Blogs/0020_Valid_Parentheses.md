# [Algorithm] LeetCode 20: 有效的括号 - 栈的哲学与消消乐

> **发布时间**: 2026-01-25
> **标签**: `C++` `LeetCode` `Stack` `String`

## 1. 问题背景 (The Problem)

**LeetCode 20. Valid Parentheses**
给定一个只包括 `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'` 的字符串，判断字符串是否有效。
有效性要求：左括号必须用相同类型的右括号闭合，且必须以正确的顺序闭合。

* **示例**：`"()[]{}"` (True), `"([)]"` (False - 顺序错了), `"]"` (False - 没得配).
* **地位**：这是数据结构中 **栈 (Stack)** 的 "Hello World"，也是大厂面试考察基本功的必考题。

## 2. 核心逻辑：后进先出 (LIFO)

解决这道题的直觉，就像玩 **“开心消消乐”**。

我们需要一个容器来存放 **“等待被匹配的左括号”**。
由于括号必须由内向外闭合（最近进入的左括号，必须最先被消除），这完美契合了 **栈 (Stack)** 的 **后进先出 (Last In First Out)** 特性。

**算法流程**：
1.  **扫描**：遍历字符串的每一个字符。
2.  **入栈**：遇到左括号，将其（或其期待的另一半）压入栈底。
3.  **消除**：遇到右括号，检查栈顶元素是否匹配。
    * 匹配成功：弹出栈顶（消消乐）。
    * 匹配失败：直接返回 `false`。
4.  **终局**：遍历结束，栈必须为空（所有坑都填平了）才算成功。

## 3. C++ 避坑指南 (Syntax Traps)

在实现过程中，有几个 C++ 特有的坑点需要注意：

### A. 单引号 vs 双引号
* `'('` (char)：这是一个**字符**，底层是 ASCII 码整数。栈 `stack<char>` 里装的是这个。
* `"("` (string)：这是一个**字符串**（字符数组），占用的内存包含结束符 `\0`。
* **口诀**：*栈里只装一粒米 (char)，别硬塞进一袋米 (string)。*

### B. 范围 For 循环 (Range-based for loop)
C++11 的优雅写法，遍历字符串不再需要迭代器或索引：
```cpp
for (char c : s) {
    // c 就是 s 中的每一个字符副本
}
```

### C. 空栈崩溃 (SegFault)
当输入为 `"]"` 时，栈是空的。此时如果直接调用 `st.top()`，程序会直接 **Segmentation Fault**。
**铁律**：在访问 `top()` 之前，必须先检查 `!st.empty()`。

## 4. ZJU 标准代码 (The Optimized Solution)

这里采用一种 **“预判入栈”** 的高级写法。
**思路**：遇到左括号时，直接把 **“期待的右括号”** 压入栈中。这样后续比较时，只需要看 `c == st.top()` 即可，逻辑极其精简。

```cpp
#include <stack>
#include <string>

class Solution {
public:
    bool isValid(string s) {
        // 剪枝：奇数长度一定无法完全配对
        if (s.length() % 2 != 0) return false;
        
        stack<char> st;
        
        for (char c : s) {
            // 策略：遇到左括号，存入"期待的右括号"
            if (c == '(') st.push(')');
            else if (c == '{') st.push('}');
            else if (c == '[') st.push(']');
            // 处理右括号
            else {
                // 1. 栈空了 (前面没有左括号来配对)
                // 2. 栈顶不匹配 (配错了类型)
                if (st.empty() || st.top() != c) return false;
                
                // 匹配成功，弹出栈顶
                st.pop();
            }
        }
        
        // 只有栈空了，才算完美闭环
        return st.empty();
    }
};
```