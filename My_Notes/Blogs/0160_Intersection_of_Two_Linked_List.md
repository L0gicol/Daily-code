# [Algorithm] LeetCode 160: ç›¸äº¤é“¾è¡¨ - ä»£ç é‡Œçš„æè‡´æµªæ¼«

> **å‘å¸ƒæ—¶é—´**: 2026-01-24
> **æ ‡ç­¾**: `C++` `LeetCode` `Two Pointers` `Romantic Code`

## 1. é—®é¢˜èƒŒæ™¯ (The Problem)

**LeetCode 160. Intersection of Two Linked Lists**
ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `headA` å’Œ `headB`ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨ä¸å­˜åœ¨ç›¸äº¤èŠ‚ç‚¹ï¼Œè¿”å› `null`ã€‚

* **éš¾ç‚¹**ï¼šä¸¤ä¸ªé“¾è¡¨é•¿åº¦ä¸ä¸€æ ·ã€‚å¦‚æœä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶å‡ºå‘ï¼Œæ— æ³•åœ¨â€œèµ·è·‘çº¿ä¸åŒâ€çš„æƒ…å†µä¸‹åŒæ—¶åˆ°è¾¾äº¤ç‚¹ã€‚
* **çº¦æŸ**ï¼šè¦æ±‚ $O(N)$ æ—¶é—´å¤æ‚åº¦ï¼Œ$O(1)$ ç©ºé—´å¤æ‚åº¦ã€‚

## 2. æ ¸å¿ƒæ€è·¯ï¼šåŒå‘å¥”èµ´ (The "Romantic" Algorithm)

è¿™é“é¢˜çš„å®˜æ–¹è§£æ³•å¸¸è¢«ç§°ä¸º **â€œæµªæ¼«ç®—æ³•â€**ã€‚

### ğŸ’¡ ç›´è§‰
æˆ‘ä»¬æ— æ³•æ¶ˆé™¤é“¾è¡¨çš„**é•¿åº¦å·®**ï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡**â€œäº’æ¢é“è·¯â€**æ¥æ¶ˆé™¤è¿™ä¸ªå·®å¼‚ã€‚
* æŒ‡é’ˆ `p1`ï¼šèµ°å®Œ A é“¾è¡¨åï¼Œç«‹åˆ»è·³å»èµ° B é“¾è¡¨ã€‚
* æŒ‡é’ˆ `p2`ï¼šèµ°å®Œ B é“¾è¡¨åï¼Œç«‹åˆ»è·³å»èµ° A é“¾è¡¨ã€‚

### ğŸ“ æ•°å­¦è¯æ˜
å‡è®¾ A ç‹¬æœ‰é•¿åº¦ä¸º $a$ï¼ŒB ç‹¬æœ‰é•¿åº¦ä¸º $b$ï¼Œå…¬å…±é•¿åº¦ä¸º $c$ã€‚
**ä¸¤æ¡è·¯çº¿çš„æ€»è·¯ç¨‹å®Œå…¨ç›¸ç­‰**ï¼š
1.  `p1` çš„è½¨è¿¹ï¼š$a + c + b$
2.  `p2` çš„è½¨è¿¹ï¼š$b + c + a$

**ç»“è®º**ï¼š
åªè¦æŒ‰ç…§è¿™ä¸ªè§„åˆ™èµ°ï¼Œæ— è®ºè°é•¿è°çŸ­ï¼Œå®ƒä»¬ä¸€å®šä¼š**åœ¨åŒä¸€æ—¶åˆ»**åˆ°è¾¾é‚£ä¸ªâ€œç›¸äº¤ç‚¹â€ã€‚å³ä½¿æ²¡æœ‰ç›¸äº¤ç‚¹ï¼Œä¹Ÿä¼šåœ¨ç»ˆç‚¹åŒæ—¶å˜æˆ `nullptr`ã€‚

## 3. ZJU æ ‡å‡†ä»£ç  (ZJU Standard Code)

åˆ©ç”¨ C++ ä¸‰å…ƒè¿ç®—ç¬¦ï¼Œå°†é€»è¾‘å‹ç¼©è‡³æç®€ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 * int val;
 * ListNode *next;
 * ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p1 = headA;
        ListNode *p2 = headB;
        
        // åªè¦æ²¡ç›¸é‡ï¼ˆæˆ–è€…æ²¡åŒæ—¶èµ°åˆ°å°½å¤´ï¼‰ï¼Œå°±ä¸€ç›´èµ°
        while (p1 != p2) {
            // p1 èµ°å®Œäº†å—ï¼Ÿèµ°å®Œäº†å»å¯¹æ–¹çš„ä¸–ç•Œ(headB)çœ‹çœ‹ï¼Œæ²¡èµ°å®Œç»§ç»­èµ°
            p1 = (p1 == nullptr) ? headB : p1->next;
            
            // p2 èµ°å®Œäº†å—ï¼Ÿèµ°å®Œäº†å»å¯¹æ–¹çš„ä¸–ç•Œ(headA)çœ‹çœ‹ï¼Œæ²¡èµ°å®Œç»§ç»­èµ°
            p2 = (p2 == nullptr) ? headA : p2->next;
        }
        
        // æœ€ç»ˆ p1 è¦ä¹ˆæ˜¯äº¤ç‚¹ï¼Œè¦ä¹ˆæ˜¯ nullptr (æ— ç¼˜)
        return p1;
    }
};

## 4. å½©è›‹ï¼šå…³äº nullptr çš„ç¢ç¢å¿µ (Easter Egg)


å¦‚æœæŠŠ **p1** æ¯”ä½œæˆ‘ï¼ŒæŠŠ **p2** æ¯”ä½œå¥¹ã€‚
æˆ‘ä»¬èµ·è·‘çº¿ä¸åŒï¼Œäººç”Ÿè½¨è¿¹ä¹Ÿé•¿çŸ­ä¸ä¸€ã€‚

ç®—æ³•è®©æˆ‘ä»¬åšäº†ä¸€æ¬¡å°è¯•ï¼š**â€œæˆ‘èµ°è¿‡æˆ‘èµ°è¿‡çš„è·¯ï¼Œä¹Ÿè¯•ç€å»èµ°ä¸€éä½ èµ°è¿‡çš„è·¯ã€‚â€**

å¦‚æœæˆ‘ä»¬åœ¨æŸä¸ªèŠ‚ç‚¹ç›¸é‡äº†ï¼Œé‚£æ˜¯å¹¸è¿ï¼Œé‚£æ˜¯ `Intersection`ã€‚
ä½†æ›´å¤šçš„æ—¶å€™ï¼Œç°å®æ˜¯ **`Case 2: No Intersection`**ã€‚

è¿™æ—¶å€™ï¼Œç®—æ³•ç»™å‡ºçš„ç»“å±€å¹¶ä¸æ˜¯æŠ¥é”™ (`Error`)ï¼Œä¹Ÿä¸æ˜¯æ­»å¾ªç¯ (`Loop`)ã€‚
è€Œæ˜¯ï¼š

> æˆ‘èµ°å®Œäº†æˆ‘çš„è·¯ï¼Œä¹Ÿè¯»å®Œäº†ä½ çš„è·¯ã€‚
> ä½ èµ°å®Œäº†ä½ çš„è·¯ï¼Œä¹Ÿè¯»å®Œäº†æˆ‘çš„è·¯ã€‚
> æœ€åï¼Œæˆ‘ä»¬åœ¨ `nullptr` å¤„ç›¸é‡ã€‚
>
> `while (p1 != p2)` å¾ªç¯ç»“æŸäº†ï¼Œè¿”å› `null`ã€‚
> æ²¡æœ‰äº¤é›†ï¼Œä½†ä¹Ÿæ²¡æœ‰é—æ†¾ã€‚
> æˆ‘ä»¬éƒ½åœ¨ç”Ÿå‘½çš„è¾¹ç•Œå¤„ï¼Œæ®Šé€”åŒå½’ï¼Œä½“é¢åœ°é€€å‡ºäº†å¾ªç¯ã€‚

***"Even if we don't intersect, we meet at the end."***