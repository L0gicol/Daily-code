# [Algorithm] LeetCode 206: 反转链表 - 从栈直觉到双指针优化

> **发布时间**: 2026-01-21
> **标签**: `C++` `LeetCode` `Data Structure`

## 1. 问题背景 (Problem)

在复习数据结构时，刷到了经典的 **LeetCode #206 反转链表 (Reverse Linked List)**。
题目要求反转一个单链表。这虽然是链表操作的基础题，但在处理 C++ 指针内存管理、边界条件以及空间复杂度优化时，有很多值得深挖的细节。

本文记录了从“直觉解法”到“工程最优解”的演进过程，以及调试过程中遇到的坑。

## 2. 初次尝试：栈 (Stack) 的物理直觉

看到“反转”二字，第一反应是利用栈 **LIFO（后进先出）** 的特性。
这非常符合物理直觉：把链表节点一个个“装进桶里”，再一个个“倒出来”重新连接。

### 核心逻辑
1.  遍历链表，将所有 `ListNode*` 指针压入 `std::stack`。
2.  弹出栈顶元素，作为新的头节点。
3.  循环出栈，将节点依次连接。
4.  **收尾**：原链表的头节点（现在的尾节点）的 `next` 必须置空，防止成环。

### 局限性
虽然逻辑简单，但空间复杂度为 $O(N)$。在系统底层开发或处理大规模数据时，额外的内存开销是不被允许的。因此，必须掌握原地反转的解法。

## 3. 进阶优化：双指针迭代 (Iterative) - 推荐

为了实现 $O(1)$ 的空间复杂度，我们需要在原链表上直接修改指针方向。
这种解法通常被称为“双指针法”，但我认为实际上需要**三个视角的指针**配合：

* **`prev` (前驱)**：指向“前一个”节点（反转后的目标方向）。
* **`curr` (当前)**：指向当前正在处理的节点。
* **`next` (后继)**：临时保存“下一个”节点，防止链表断裂。

### 标准代码 (C++ STL Style)

这是符合工程规范的标准写法：

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // prev 初始化为 nullptr，天然解决了新链表尾部指向空的问题
        ListNode* prev = nullptr; 
        ListNode* curr = head;

        while (curr != nullptr) {
            // 1. 【记路】暂存后继节点，防止断链
            ListNode* nextTemp = curr->next; 
            
            // 2. 【反转】核心动作：将当前节点的指针指向前驱
            curr->next = prev;               
            
            // 3. 【推进】prev 和 curr 整体向后移动一步
            prev = curr;                     
            curr = nextTemp;                 
        }
        
        // 循环结束时，curr 为 null，prev 正好停在新的头节点上
        return prev; 
    }
};
```

### 记忆口诀
> "先存后继，再指前任。前任上位，现任后移。"

## 4. 避坑指南 (Debug Notes)

在从思路转化为代码的过程中，复盘了两个致命错误：

### 坑点一：环的产生 (The Cycle)
**现象**：程序超时 (Time Limit Exceeded) 或内存溢出。
**原因**：如果在初始化时没有正确切断原头节点的连接，或者没有将 `prev` 初始化为 `nullptr`，原头节点和原第二节点会形成环状引用（`1->2->1...`）。
**修正**：始终确保新链表的尾节点 `next` 指向 `nullptr`。

### 坑点二：野指针 (Wild Pointer)
**现象**：Segmentation Fault。
**原因**：在 C++ 中声明指针（如 `ListNode* p`）后未初始化直接使用。
**修正**：指针声明后必须思考它指向哪里，或者初始化为 `nullptr`。

## 5. 总结
1.  **思维跃迁**：从 Stack 的“空间换时间”优化到双指针的“原地操作”，是算法能力的体现。
2.  **代码规范**：处理链表问题时，永远要先问自己两个问题：“链断了吗？”和“尾巴封口了吗？”。